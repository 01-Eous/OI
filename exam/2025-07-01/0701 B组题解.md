相信部分分给的非常充足，平均分应该至少 $240$，高分或许有 $320$ 多？可能特殊性质给少了一点，区分度会很奇怪。

## 多线并行

签到题，过于简单，不知道部分分拿来干什么。

### 算法 0

我不会，本来准备不给部分分，但放了一些给**可能**存在的做法，或者说给一些写挂后**可能**存在的保底分。

### 算法 1

可以注意到每一个时刻我们思考完毕并没有放弃的题目最多为 $1$。暴力枚举思考题目的顺序，对于相邻的两道题目，判断在思考后一道的同时能否放弃前一道。时间复杂度 $O(\sum n!)$。

### 算法 2

首先将所有的 $a_i$ 排序。由于思考题目的时间是无法节省的，我们的主要目标为尽量多的在思考题目时放弃题。从 $a_i$ 的最大值开始考虑，若此时 $a_{max} + a_{min} > m$，则在思考完 $a_{max}$ 后，必须花费 $1$ 的时间放弃该题，再去思考其他问题，否则，思考完 $a_{max}$ 后立刻思考 $a_{min}$，而之后的 $a_{min}$ 由于可以满足最大值，所以也可以满足任何元素。

可以发现两种情况分别对应 $n - 1$ 与 $n - 2$ 两种子问题，可以双指针处理。

## 空当接球

防 $\text{ak}$ 题。

### 算法 0

一通乱搞，可以获得相当可观的分数。

### 算法 0.2

我们每一次尽量操作相邻距离较小的元素，随机情况下，元素会较快的减少。

### 算法 1

每次随机两个数进行操作。

### 算法 1.2

每一次选择 $3$ 个数，在它们中随机进行操作，直至每一个变为 $0$。

### 算法 2

当 $n \times m$ 较小时。可以 $\text{dp}$ 记录出三个数时的转移路径，每次消除一个数。

### 算法 2.2

如果一直操作某一些数，会让值域增长过快。不如分治的来处理，降低增长速度。

### 算法 3

当 $m = 1$ 时，我们可以每一次消除两个相同的数，这样最终一定只会剩余 $\log$ 级别个数，或许可以按照算法 $1$ 处理。

### 算法 4

从这里开始与部分分对应不大。考虑我们在算法 $3$ 中进行了什么操作，核心是缩小了有值的数的个数，最终剩余若干个 $2^k$。这提示我们往二进制方向考虑。按二进制位从低到高来枚举，假设当前在考虑第 $x$ 位，每一次若存在 $> 1$ 个最低位为 $x$ 的元素，我们操作其中的任意两个，会发现这两个数的最低为均升高。所以最终对于每一个 $x$，最低位为 $x$ 的最多只会保留 $1$ 个元素。

这样大大的缩减了范围，最终有值的个数为 $\log$ 个，操作数量级别 $n \log nm$。

### 算法 5

不妨探寻一下算法 $4$ 的本质。假设当前操作的两个元素分别为 $a,b(a > b)$，且它们最低位相同，从二进制的角度观察，$b$ 会左移一位，$a$ 的最低位会变成 $a,b$ 不同的最低位。那么当 $a,b$ 在从低位上往上，连续相同的个数越多，$a$ 的最低位升高越大。很容易联想到 $\text{trie}$ 树的结构。

首先对所有的数建一棵从低位到高位的 $\text{trie}$ 树，我们不停地往 $\text{trie}$ 树的 $0$ 儿子方向移动，并在经过的点上处理 $1$ 儿子，使得该 $1$ 儿子最终子树中之多只有一个剩余元素。

现在考虑处理一个 $1$ 儿子子树的情况。首先，$\text{lca}$ 深度越大的两个元素合并，较大值最低位的变化越大，那么我们从底到顶的合并。对于一个 $x$，若它 $01$ 儿子都还存在剩余元素，将其合并。否则保持不变，继续递归向上处理。

同算法 $4$，操作完成后只会剩余 $\log$ 个元素，操作数量级别为 $n$。

> 并不严谨的证明一下操作数量级别，下面粗略的将 $\log n,\log m,\log nm$ 等视为同一级别。
> 
> 定义一个元素 $x$ 的势能 $f(x)$ 为 $\log nm - i$，$i$ 为元素 $x$ 的最低位。整个序列的势能 $F(x) = \sum_{i \in S} f(i)$，初始势能最多为 $n \log nm$。
> 考虑我们在 $\text{trie}$ 树上的操作，不妨假想这棵 $\text{trie}$ 树是一棵满二叉树。
>
>很显然可以发现，对于树上为每一节点，以它为 $\text{lca}$ 最多只会合并一次，且这一次合并减少的势能为 $1 + dep_{lca}$，约为该点的深度。 
> 
> 那么我们可以抽象出这样的一个模型。现在有 $\log$ 个满二叉树(因为总共考虑了 $\log$ 个 $1$ 儿子节点子树)，树上的每一个节点有一个权值，该权值为它的深度。现在我们会从中选择若干个点，使得它们的权值和不超过 $M$，求最多选择的节点数。
> 
> 考虑选择完深度 $\le x$ 的所有节点，此时选择的总节点个数为 $2^x \log$，总权值为 $2^x \log \cdot \log$，所以我们想要达到 $n \log nm$ 的势能需要选择的点数级别约为 $n$，实际情况中或许存在 $\frac {\log nm} {\log n}$ 的常数。 

### 算法 6

最终的问题只剩下如何快速的合并剩余的 $\log$ 个元素。我们尝试设计一种算法，每次选择 $3$ 个有值的元素 $a,b,c$，尝试将其中之一变为 $0$。

不妨设 $a < b < c$。我们还是从二进制方向考虑，这里我们不断的降低这三个元素的最小值。设 $t = \lfloor \frac {b} {a} \rfloor$，从低到高一次考虑 $t$ 的每一个二进制位。若为 $0$，操作 $(a,c)$，否则操作 $(a,b)$。

可以发现，通过这样的一整轮操作，我们将 $b$ 变为了 $b \bmod a$，降低了三元组的最小值。在多次迭代的过程中，$b$ 的值在模 $c$ 意义下与随机相似，所以在期望 $O(1)$ 次可以将三元组的最小值减半。操作次数级别为 $O(\log^3 nm)$，远远不及 $n$。

如果有更优秀的算法或更严谨的证明欢迎提供。

## 列序号括

非常清新的数据结构题。

### 算法 0

一通乱搞，我也不知道能拿多少分。

### 算法 1

下面统称 $n = |s|$。

暴力枚举删除的哪一些括号并判断合法。时间复杂度 $O(2^n poly(n))$。

### 算法 2

留给暴力 $\text{dp}$。

设 $f_{i,j}$ 表示考虑到了第 $i$ 个，现在前面删除的左括号个数为 $j$ 的字典序最小字符串。转移时需要 $O(n)$ 判断两个字符串字典序大小，复杂度 $O(n^3)$。

### 算法 3

需要观察到一个比较重要的性质，若删除 $i,j(i < j)$ 的左括号与右括号，最终序列中 $i,j$ 之间一定都被删空，否则不优，或者能够使用其他方式代替。并且通过这个性质我们可以递归说明，$[i,j]$ 一定是一个合法括号序列。

考虑倒序 $\text{dp}$。设 $f_i$ 表示只考虑 $[i, n]$ 时最终的答案。两种转移，由 $f_{i+1}$ 添加 $s_i$ 或由 $f_{j+1}$ 转移而来，其中 $j$ 是满足 $[i,j]$ 为合法括号序列的最小的 $j$。 

时间复杂度 $O(n^2)$。

### 算法 4

算法 $3$ 的时间复杂度瓶颈在于比较两个字符串字典序，使用数据结构优化。使用主席树或可持久化平衡树维护前缀哈希值，比较时二分即可。由于每次是在最开头添加字符，只能做到 $O(n \log^2 n)$。

### 算法 5

倍增显然能够更好的维护该类结构，使用两个倍增数组，分别维护位置与前缀哈希值即可。时间复杂度 $O(n \log n)$。代码长度不超过 $1k$。

## 可爱路径

部分分给的很多，区分度应该不大，绑点只是因为原数据绑点。

你可能觉得大样例过水，其实不是，是数据过水。在原数据中，使用算法 $1$ 可以通过算法 $3$ 中 $100 \%$ 的数据，现在可以通过 $90 \%$。


### 算法 1

最短路。

### 算法 2

可以记录 $f_{i,j,k}$ 表示依次经过 $i,j,k$，当前在 $k$ 的合法最短路。类似最短路转移。复杂度 $O(n^2m \log m)$。

### 算法 3

若该禁止路径可以不在最短路上，输出最短路。

否则该禁止路径一定不会存在重复点，设 $f_{i,0/1}$ 表示到了 $i$，该路径后缀是否能够匹配禁止路径前缀，类似最短路转移。复杂度 $O(m \log m)$。

### 算法 4

设 $n,m,\sum p$ 同阶。

在算法 $3$ 中，我们可以隐约感觉到这是一个失配的过程。考虑将所有的禁止路径与单点建出 $\text{AC}$ 自动机，那么该自动机上才是我们所需要关心的状态，状态级别为 $O(n)$。

如果你直接在自动机上枚举出边，边数为 $O(n^2)$ 级别，显然行不通。但对于一个节点 $x$ 来说，它的 $\text{fail}$ 节点与它本身之间的出边有着非常大的相似度。具体来说，只会有以 $x$ 为前缀的禁止路径带来的下一步转移不同，总共只有 $\sum p$ 的差异。

维护 $\text{fail}$ 与当前点不同的转移，可以通过主席树来实现。进行最短路时由于每一个节点只会被松弛一次，复杂度为 $O(m \log m)$。